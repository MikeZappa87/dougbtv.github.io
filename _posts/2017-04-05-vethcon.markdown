---
author: dougbtv
comments: true
date: 2017-04-05 12:04:00-05:00
layout: post
slug: vethcon
title: vethcon - Connect Docker containers together with virtual ethernet connections
category: nfvpe
---

Let's dig into [vethcon](https://github.com/s1061123/vethcon) created by [Tomofumi Hayashi](https://github.com/s1061123). vethcon is a utility written in Go that gives us a way to connect containers together with "veth" (virtual ethernet) devices -- a feature available in the Linux kernel. This allows us to specify interfaces that the containers use and link them together -- all without using Linux bridges. vethcon has become a cornerstone of the [zebra-pen](https://github.com/dougbtv/zebra-pen) project, an effort I'm involved in to analyze gaps in containerized NFV workloads, specifically it routes traffic using Quagga, and we setup all the interfaces using vethcon. The project really took a turn for the better when Tomo came up with vethcon and we implemented it in zebra-pen. Ready to see vethcon in action? Let's jump in the pool!

We'll talk about the back-story for what veth interfaces are maybe look a little bit about linux network namespaces. Then we'll dissect vethcon itself and step through what it's doing. 

Last but not least -- what fun would it be if we didn't fire up vethcon and get it working? If you're less interested in the back story, just scroll down to the "Ready, set, compile!" section. From there you can get your hands on the keyboard and dive into the fun stuff. Our goal will be to compile vethcon, connect two containers with one another, look at those interfaces and get a ping to come across them. 
 
We'll just connect a couple containers together, but, using vethcon you can also connect network namespaces to containers, and network namespaces to network namespaces, too. 

Another note before we kick this off -- vethcon's life has really just begun, it's useful and functional as it is. But, Tomo has bigger and better ideas for it -- there's some potential in the future for creating vxlan interfaces, and getting it working with CNI -- but, there's still experimentation to be done there, and I don't want to spoil it by saying too much. So, as I've heard said before "That's another story for another bourbon."

## Requirements

If you want to sing along -- the way that I'm going through this is using a fresh install of CentOS 7. In my case I'm using the generic cloud image. Chances are this will be very similar with a RHEL or Fedora install. But if you want to play along the same exact way, spin yourself up a fresh CentOS 7 VM. 

You're also going to need a spankin' fresh version of Docker. So we'll install from the official Docker RPM repos and install a really fresh one.

## The back-story

vethcon leverages "veth" -- as evidenced by its name. veth interfaces aren't exactly new, [veth devices were proposed way back in '07](https://lwn.net/Articles/232688/). The original authors describe veth as:

> Veth stands for Virtual ETHernet. It is a simple tunnel driver
that works at the link layer and looks like a pair of ethernet
devices interconnected with each other.

veth interfaces come in pairs, and that's what we'll do in a bit, we'll pair them up together with two containers. If you'd like to see some diagrams of veth pairs in action -- I'll point you to [this article from opencloudblog which has does a nice job illustrating it](http://www.opencloudblog.com/?p=66).

Another concept that's important to the functioning of vethcon is "network namespaces". [Linux namespaces](https://en.wikipedia.org/wiki/Linux_namespaces) is the general concept here that allows network namespaces -- in short they give us a view of resources that are limited to a "namespace". Linux namespaces are a fundamental part of how containers function under Linux, it provides the over-arching functionality that's necessary to segregate processes and users, etc. This isn't new either -- apparently it begun in 2002 with mount-type namespaces.

With network namespaces, in Linux all of your interfaces and routing tables are all mashed together and available to one another. With network namespaces, you can isolate these from one another, so they can work independently from one-another. This will give processes a specific view of these interfaces. 

## Let's look at the vethcon go code.

So, what's under the hood? In essence, vethcon uses a few modules and then provides some handling for us to pick out the container namespace and assign veth links to the containers. Its simplicity is its elegance, and quite a good idea.

Let's first look at the modules, then, I'll point you through the code just a touch, in case you wanted to get in there and look a little deeper.

### The libraries

* [vishvananda/netlink](https://github.com/vishvananda/netlink): does cool things like you'd do as a user like `ip link add`
* [containernetworking/cni/pkg/ns](https://github.com/containernetworking/cni/tree/master/pkg/ns): The namespace package from the CNI project. Used to access network namespaces.
* [docker/docker/client](https://github.com/docker/docker/tree/master/pkg): The docker client (to access, y'know, docker containers, specifically to inspect the container and get its network settings)

And other things that are more utilitarian, such as [package context](https://godoc.org/golang.org/x/net/context), [c-style getopts](github.com/mattn/go-getopt), and internal built-ins like `os`,`fmt`,`net`, etc.

### Application flow

At it's core, vethcon defines a data object called `vEth`, which gives us a structure to store some information about the connections that we'll make.

It's a `struct` and is defined as so:

```go
// ---------------------------------------------------- -
// ------------------------------ vEth data object.  - -
// -------------------------------------------------- -
// -- defines a data object to describe interfaces
// -------------------------------------------------- -

type vEth struct {
    // What's the network namespace?
    nsName string
    // And what will we call the link.
    linkName string
    // Is there an ip address?
    withIPAddr bool
    // What is that ip address.
    ipAddr net.IPNet
}
```

In some fairly terse diagramming using [asciiflow](http://asciiflow.com/), the general application flow goes as follows... (It's high level, I'm missing a step or two, but, it'd help you dig through the code a bit if you were to step through it)

```
main()
  +
  |
  +------> parseDOption()  (parse -d options from cli)
  |
  +------> parseNOption()  (parse -n options from cli)
  |
  +------> makeVeth(veth1, veth2) with vEth data objects
               +
               |
               +------>  getVethPair(link names)
               |             +
               |             |
               |             +------>  makeVethPair(link)
               |                          +
               |                          |
               |                          +----> netlink.Veth()
               |
               +------>  setVethLink(link) for link 1 & 2
```


## Ready, set, compile!

Ok, first let's get *ready* and install the dependencies that we need. Go makes it really easy on us -- it handles its own deps and we basically will just need golang, git and Docker.

```bash

# Enable the docker ce repo
[centos@vethcon ~]$ sudo yum-config-manager     --add-repo     https://download.docker.com/linux/centos/docker-ce.repo

# Install the deps.
[centos@vethcon ~]$ sudo yum install -y golang git docker

# Start and enable docker
[centos@vethcon ~]$ sudo systemctl start docker && sudo systemctl enable docker

# Check that docker is working
[centos@vethcon ~]$ sudo docker ps

```

Now let's *set* the gopath and git clone the code.

```bash
# Set the go path
[centos@vethcon ~]$ rm -Rf gocode/
[centos@vethcon ~]$ mkdir -p gocode/src
[centos@vethcon ~]$ export GOPATH=/home/centos/gocode/

# Clone vethcon
[centos@vethcon ~]$ git clone https://github.com/s1061123/vethcon.git /home/centos/gocode/src/vethcon

```


Finally, we'll grab the dependencies and *compile* vethcon.

```
# Fetch the dependencies for vethcon
[centos@vethcon ~]$ cd gocode/
[centos@vethcon gocode]$ go get vethcon

# Now, let's compile it
[centos@vethcon ~]$ go build vethcon

```

Alright, should be good to go -- usually I'd say "let's look at the help" now that it's compiled, but, there's no help yet! (So I'm submitting a pull request, try ith with `./vethcon -h` in case the PR landed)

## Make a handy-dandy little Docker image

## Let's run some

```
   41  ./vethcon -d centos1:nic1:10.10.1.2/24 -d centos2:nic2:10.10.1.3/24
   42  ./vethcon -d centos1:test1:10.10.1.2/24 -d centos2:test2:10.10.1.3/24
   43  docker exec -it centos1 ping -c2 10.10.1.3
```

## Let's give 'er a run!
